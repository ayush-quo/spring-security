package com.self.springsecurityoathserver.security;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;


@EnableAuthorizationServer
@Configuration
public class AuthSecurityConfig extends AuthorizationServerConfigurerAdapter {

  @Autowired
  AuthenticationManager authenticationManager;

  @Autowired
  UserDetailsService userDetailsService;


  @Override public void configure(final AuthorizationServerSecurityConfigurer security) throws Exception {
    security.passwordEncoder(NoOpPasswordEncoder.getInstance())
            .checkTokenAccess("isAuthenticated()");     // This statement is for introspection URL -> oauth/check_token
  }

  @Override public void configure(final ClientDetailsServiceConfigurer clients) throws Exception {
    /*
      In Password Grant type, the user sends its creds to client which then sends it to Auth. server. See URL, we pass username password in params.
       It is deprecated.
     */
    clients.inMemory()
           .withClient("client1")
           .secret("secret1")
           .scopes("read")
           .authorizedGrantTypes("password")        //localhost:8080/oauth/token?grant_type=password&username=user&password=1234&scope=read
           .and()
           /*
              In Authorization code grant type, the user doesn't send its creds to client, but directly log into the Auth server. The Auth server
              then generates the code for the client. The client sends this token back to Auth server in second request, whcih helps authorization
              server to know that this is the same client that asked for the code. This code can only be used once to get the final token. When
              code is generated by auth server, it redirects to the URL(of client) we provide and code is appended into params of that URL. When
              authorized, auth. server generates the final token through which client accesses the required APIs of Resource server.
            */
           .withClient("client2")
           .secret("secret2")
           .scopes("read")
           .authorizedGrantTypes("authorization_code")
           .redirectUris(
             "http://localhost:9080")    //http://localhost:8080/oauth/authorize?response_type=code&client_id=client2&scope=read; ->
           // localhost:8080/oauth/token?grant_type=authorization_code&scope=read&code=<>
           .and()
           /*
              In client_credentials grant type, there is no need for the user's creds. Authorization is done only on the basis of client's creds.
            */
           .withClient("client3")
           .secret("secret3")
           .scopes("read")
           .authorizedGrantTypes("client_credentials") // localhost:8080/oauth/token?grant_type=client_credentials&scope=read
           .and()
           /*
                Refresh token grant type is always used with another grant type. It helps us to generate another token without storing the user's
                creds and making him authenticate again. A refresh token with authorization token is generated. this token helps to generate
                another authorization token if required.
            */
           .withClient("client4")
           .secret("secret4")
           .scopes("read")
           .authorizedGrantTypes("password", "refresh_token")

           .and()
           .withClient("resource")
           .secret("12345");
  }

  @Override public void configure(final AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
    endpoints.authenticationManager(authenticationManager);
    endpoints.userDetailsService(userDetailsService);
  }
}
